"""Abstract base class for trading strategies."""

from abc import ABC, abstractmethod
from dataclasses import dataclass, field
from datetime import datetime
from enum import Enum
from typing import Optional
import uuid

from models.candle import Candle
from models.order import Order
from models.position import Position


class SignalType(Enum):
    """Trading signal type enumeration."""

    NONE = "none"
    LONG = "long"
    SHORT = "short"
    EXIT_LONG = "exit_long"
    EXIT_SHORT = "exit_short"
    EXIT_ALL = "exit_all"


@dataclass
class StrategySignal:
    """
    Trading signal generated by a strategy.

    Attributes:
        signal_type: Type of signal (long, short, exit, etc.)
        symbol: Trading symbol
        price: Suggested entry/exit price
        stop_loss: Suggested stop loss
        take_profit: Suggested take profit
        quantity: Suggested position size (if calculated)
        confidence: Signal confidence (0.0 - 1.0)
        reason: Human-readable reason for the signal
        metadata: Additional signal metadata
    """

    signal_type: SignalType
    symbol: str
    price: Optional[float] = None
    stop_loss: Optional[float] = None
    take_profit: Optional[float] = None
    quantity: Optional[float] = None
    confidence: float = 1.0
    reason: str = ""
    timestamp: datetime = field(default_factory=datetime.now)
    signal_id: str = field(default_factory=lambda: str(uuid.uuid4()))
    metadata: dict = field(default_factory=dict)

    @property
    def is_entry(self) -> bool:
        """Check if signal is an entry signal."""
        return self.signal_type in [SignalType.LONG, SignalType.SHORT]

    @property
    def is_exit(self) -> bool:
        """Check if signal is an exit signal."""
        return self.signal_type in [
            SignalType.EXIT_LONG,
            SignalType.EXIT_SHORT,
            SignalType.EXIT_ALL,
        ]

    @property
    def is_long(self) -> bool:
        """Check if signal is long."""
        return self.signal_type == SignalType.LONG

    @property
    def is_short(self) -> bool:
        """Check if signal is short."""
        return self.signal_type == SignalType.SHORT

    def to_dict(self) -> dict:
        """Convert signal to dictionary."""
        return {
            "signal_id": self.signal_id,
            "signal_type": self.signal_type.value,
            "symbol": self.symbol,
            "price": self.price,
            "stop_loss": self.stop_loss,
            "take_profit": self.take_profit,
            "quantity": self.quantity,
            "confidence": self.confidence,
            "reason": self.reason,
            "timestamp": self.timestamp.isoformat(),
            "metadata": self.metadata,
        }


class BaseStrategy(ABC):
    """
    Abstract base class for all trading strategies.

    All strategy implementations must inherit from this class and implement
    the required abstract methods.
    """

    def __init__(
        self,
        name: str,
        symbol: str,
        timeframe: str = "M5",
        magic_number: int = 0,
    ):
        """
        Initialize strategy.

        Args:
            name: Strategy name.
            symbol: Trading symbol.
            timeframe: Candle timeframe.
            magic_number: Unique identifier for strategy's orders.
        """
        self.name = name
        self.symbol = symbol
        self.timeframe = timeframe
        self.magic_number = magic_number
        self._enabled = True
        self._last_signal: Optional[StrategySignal] = None

    @property
    def is_enabled(self) -> bool:
        """Check if strategy is enabled."""
        return self._enabled

    def enable(self) -> None:
        """Enable the strategy."""
        self._enabled = True

    def disable(self) -> None:
        """Disable the strategy."""
        self._enabled = False

    @abstractmethod
    def initialize(self) -> bool:
        """
        Initialize strategy with required data.
        Called once when strategy is loaded.

        Returns:
            True if initialization successful, False otherwise.
        """
        pass

    @abstractmethod
    def on_candle(
        self,
        candle: Candle,
        candles: list[Candle],
    ) -> Optional[StrategySignal]:
        """
        Process a new candle and generate signal if conditions met.

        Args:
            candle: Latest candle.
            candles: Historical candles including the latest.

        Returns:
            Trading signal or None if no signal.
        """
        pass

    @abstractmethod
    def on_tick(
        self,
        bid: float,
        ask: float,
        timestamp: datetime,
    ) -> Optional[StrategySignal]:
        """
        Process a tick update.

        Args:
            bid: Current bid price.
            ask: Current ask price.
            timestamp: Tick timestamp.

        Returns:
            Trading signal or None if no signal.
        """
        pass

    def on_position_opened(self, position: Position) -> None:
        """
        Called when a position is opened by this strategy.

        Args:
            position: The opened position.
        """
        pass

    def on_position_closed(self, position: Position, pnl: float) -> None:
        """
        Called when a position is closed.

        Args:
            position: The closed position.
            pnl: Realized profit/loss.
        """
        pass

    def on_order_filled(self, order: Order) -> None:
        """
        Called when an order is filled.

        Args:
            order: The filled order.
        """
        pass

    def should_exit(
        self,
        position: Position,
        current_price: float,
        candles: Optional[list[Candle]] = None,
    ) -> Optional[StrategySignal]:
        """
        Check if an existing position should be exited.

        Args:
            position: Current open position.
            current_price: Current market price.
            candles: Recent candles (optional).

        Returns:
            Exit signal or None if should hold.
        """
        return None

    def calculate_stop_loss(
        self,
        entry_price: float,
        is_long: bool,
        candles: Optional[list[Candle]] = None,
    ) -> Optional[float]:
        """
        Calculate stop loss for a new position.

        Args:
            entry_price: Position entry price.
            is_long: True for long, False for short.
            candles: Recent candles for calculation.

        Returns:
            Stop loss price or None.
        """
        return None

    def calculate_take_profit(
        self,
        entry_price: float,
        stop_loss: float,
        is_long: bool,
    ) -> Optional[float]:
        """
        Calculate take profit for a new position.

        Args:
            entry_price: Position entry price.
            stop_loss: Stop loss price.
            is_long: True for long, False for short.

        Returns:
            Take profit price or None.
        """
        return None

    def get_status(self) -> dict:
        """
        Get strategy status and metrics.

        Returns:
            Dictionary with strategy status.
        """
        return {
            "name": self.name,
            "symbol": self.symbol,
            "timeframe": self.timeframe,
            "enabled": self._enabled,
            "magic_number": self.magic_number,
            "last_signal": self._last_signal.to_dict() if self._last_signal else None,
        }

    def reset(self) -> None:
        """Reset strategy state for a new trading day/session."""
        self._last_signal = None
